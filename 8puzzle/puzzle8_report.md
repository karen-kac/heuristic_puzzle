# 8パズル探索アルゴリズム性能比較レポート

## 1. 実験概要

### 1.1 目的
8パズル問題において、異なる探索アルゴリズムの効率性を比較し、ヒューリスティック関数の有効性を評価する。

### 1.2 実装アルゴリズム
- <strong>IDS（反復深化探索）</strong>: 情報のない探索手法
- <strong>A*(h₀)</strong>: ヒューリスティック関数 h₀(n) = 0 を用いたA*探索
- <strong>A*(h₁)</strong>: ヒューリスティック関数 h₁(n) = ゴールの位置にないタイルの数
- <strong>A*(h₂)</strong>: ヒューリスティック関数 h₂(n) = マンハッタン距離の和

### 1.3 実験設定
- 試行回数: 1000回
- 初期状態: ゴール状態からランダムに20-100ステップ移動して生成
- ゴール状態: [[1, 2, 3], [8, 0, 4], [7, 6, 5]]（0は空白タイルを示す）
- 評価指標: 展開ノード数、実行時間、メモリ使用量、解の長さ

## 2. 実験結果

### 2.1 成功率
| アルゴリズム | 成功率 | 成功回数/試行回数 |
|-------------|--------|----------------|
| IDS         | 95.8%  | 958/1000       |
| A*(h₀)      | 100.0% | 1000/1000      |
| A*(h₁)      | 100.0% | 1000/1000      |
| A*(h₂)      | 100.0% | 1000/1000      |

### 2.2 展開ノード数の比較
| アルゴリズム  | 平均       | 標準偏差     |
|-------------|------------|--------------|
| IDS         | 28,239.11  | 52,945.01    |
| A*(h₀)      | 16,932.55  | 30,392.51    |
| A*(h₁)      | 1,721.87   | 4,995.99     |
| A*(h₂)      | 183.57     | 430.73       |

### 2.3 実行時間の比較（秒）
| アルゴリズム  | 平均 | 標準偏差 |
|-------------|------|----------|
| IDS         | 0.12 | 0.22     |
| A*(h₀)      | 0.24 | 0.48     |
| A*(h₁)      | 0.02 | 0.07     |
| A*(h₂)      | 0.00 | 0.01     |

### 2.4 メモリ使用量の比較（ノード数）
| アルゴリズム  | 平均        | 標準偏差      |
|-------------|-----------|---------------|
| IDS         | 5,997.34  | 10,229.03     |
| A*(h₀)      | 22,441.60 | 36,781.69     |
| A*(h₁)      | 2,638.26  | 7,165.11      |
| A*(h₂)      | 298.06    | 674.65        |

### 2.5 解の長さの比較
| アルゴリズム  | 平均  | 標準偏差 |
|-------------|-------|----------|
| IDS         | 14.05 | 7.31     |
| A*(h₀)      | 12.78 | 5.89     |
| A*(h₁)      | 12.78 | 5.89     |
| A*(h₂)      | 12.78 | 5.89     |

<img src="results/performance_comparison_20250611_004232.png">

## 3. 分析と考察

### 3.1 主要な発見

#### <strong>発見1: ヒューリスティック関数の劇的な効果</strong>
A*(h₂)は平均<strong>183.57</strong>ノードの展開で解を発見したのに対し、IDSは平均<strong>28,239.11</strong>ノードを要した。これは約<strong>153倍</strong>の効率化を示している。

#### <strong>発見2: ヒューリスティック関数間の性能差</strong>
- h₂（マンハッタン距離）は h₁（misplaced tiles）より展開ノード数が約 <strong>9.4倍</strong>少ない（1721.87 / 183.57）。
- h₁ は h₀ より展開ノード数が約 <strong>9.8倍</strong>少ない（16932.55 / 1721.87）。
これは、アドミッシブルなヒューリスティック関数がより正確な推定値を提供することで、探索空間を効果的に枝刈りできるという理論（h₀ ≤ h₁ ≤ h₂ ≤ h*の関係）を実証している。

#### <strong>発見3: メモリ使用量のトレードオフ</strong>
IDSの平均メモリ使用量は<strong>5,997.34</strong>ノードであり、A*系の中では比較的メモリ効率が高いことが確認された。一方で、A*(h₀)は平均<strong>22,441.60</strong>ノードと最も多くのメモリを消費した。これはA*がオープンリストとクローズリストにノードを保持するため、展開ノード数が多いほどメモリ使用量が増加する傾向があることを示している。

#### <strong>発見4: 解の最適性</strong>
A*(h₀)、A*(h₁)、A*(h₂)の全てのA*アルゴリズムは、同一の平均解の長さ（<strong>12.78</strong>ステップ）を出力した。これは、これらのアドミッシブルなヒューリスティックを用いたA*探索が、<strong>最適な解（最短経路）</strong>を発見していることを明確に示している。IDSの平均解の長さが<strong>14.05</strong>とわずかに異なるのは、IDSの深さ制限の性質と、A*とは異なる探索順序に起因する可能性がある。

### 3.2 理論的考察

#### <strong>許容的ヒューリスティックの検証</strong>
A*アルゴリズムが最適な解を見つけることを保証するためには、使用されるヒューリスティック関数が<strong>許容的（Admissible）</strong>である必要がある。今回の実験結果から、h₁とh₂を用いたA*が最短経路を発見していることから、これらが実際のコストを過大評価しない許容的ヒューリスティックであることが実証された。

#### <strong>ヒューリスティック関数の優位性</strong>
実験結果は、明確にh₂ > h₁、そしてh₁ > h₀というヒューリスティック関数の優位性（dominance）を示している。より支配的なヒューリスティックは、より少ないノードを展開し、より高速に解を見つける。マンハッタン距離(h₂)が、各タイルの目標位置からの正確な「ずれ」を考慮することで、探索の方向を最も効率的にガイドしていることが裏付けられた。

#### <strong>情報のない探索vs情報のある探索</strong>
情報のない探索であるIDSやA*(h₀)は、情報のあるA*(h₁)やA*(h₂)に比べて、平均展開ノード数が非常に多く、実行時間も長くなることが示された。特に、IDSの展開ノード数の標準偏差が<strong>52,945.01</strong>と非常に大きいことは、問題の難易度によって性能が不安定になることを示唆している。対照的に、A*(h₂)の展開ノード数の標準偏差は<strong>430.73</strong>と低く、より安定した性能を発揮している。これは、問題に関する知識（ヒューリスティック）が探索効率と安定性にいかに重要であるかを示している。

### 3.3 実用的意味

#### <strong>アルゴリズム選択の指針</strong>
本実験結果に基づくと、8パズルのような探索問題において、アルゴリズム選択の指針は以下のようになる。

- メモリ制約が非常に厳しいが、ある程度の計算時間は許容できる場合: IDSが候補となる。ただし、解が非常に深い場合は非効率になる可能性がある。
- 実行速度とメモリ効率の両方を最も重視する場合: <strong>A*(h₂)（マンハッタン距離）</strong>が最も優れた選択肢となる。これは最も効率的で安定した性能を発揮する。
- 実装の単純さと中程度の効率性で十分な場合: <strong>A*(h₁)（misplaced tiles）</strong>も有効な選択肢である。
- <strong>ヒューリスティックが全くない場合（A*(h₀)）</strong>は、IDSよりも効率が悪い場合があり、推奨されない。

#### <strong>計算量の実測値</strong>
理論的な探索問題の計算量は指数オーダー <math>O(b<sup>d</sup>)</math> で表現されるが、本実験は、強力なヒューリスティック（特にh₂）を用いることで、実用的な問題サイズに対して実用的な計算量で解を導き出せることを示した。これにより、複雑な探索問題でもAI技術が有効に機能する可能性が示唆される。

## 4. 結論

### 4.1 主張文
<strong>「8パズル問題において、適切なヒューリスティック関数、特にマンハッタン距離ヒューリスティック（h₂）を使用することで、探索効率は情報のない探索に比べて150倍以上に劇的に向上し、最小の計算資源で最適な解を安定して発見できる」</strong>

### 4.2 実験の意義
1. <strong>理論の実証</strong>: 人工知能分野における探索アルゴリズム、特にA*と許容的ヒューリスティック関数の理論的な優位性が、実際の実験データによって定量的に裏付けられた。
2. <strong>実用的指針</strong>: 問題の性質と利用可能なリソース（計算時間、メモリ）に応じて、どの探索アルゴリズムとヒューリスティック関数を選択すべきかという具体的な指針を提供した。
3. <strong>設計原則</strong>: より複雑な問題領域において、効果的なヒューリスティック関数を設計する上での距離ベース手法（マンハッタン距離のような）の有効性を示唆する。

### 4.3 限界と今後の課題
- より大きなパズル（15パズル等）での検証
- 他の問題領域でのヒューリスティック設計への応用
- リアルタイム制約下での性能評価

## 5. 実装詳細

### 5.1 状態表現
```python
class PuzzleState:
    def __init__(self, board, empty_pos, parent=None, move="", cost=0):
        self.board = board          # 3x3配列
        self.empty_pos = empty_pos  # 空白位置 (row, col)
        self.parent = parent        # 親状態への参照
        self.move = move           # この状態に至る移動
        self.cost = cost           # g(n): スタートからのコスト
```

### 5.2 ヒューリスティック関数
```python
def h1(state, goal_state):
    """位置が間違っているタイルの数"""
    misplaced = 0
    for i in range(3):
        for j in range(3):
            if state.board[i][j] != 0:
                if state.board[i][j] != goal_state.board[i][j]:
                    misplaced += 1
    return misplaced

def h2(state, goal_state):
    """マンハッタン距離の総和"""
    distance = 0
    for i in range(3):
        for j in range(3):
            tile = state.board[i][j]
            if tile != 0:
                goal_i, goal_j = find_position(tile, goal_state)
                distance += abs(i - goal_i) + abs(j - goal_j)
    return distance
```

この実験により、ヒューリスティック探索の実用的価値が明確に示され、AI問題解決における知識の重要性が実証された。







